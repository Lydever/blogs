<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>对象创建的方式有哪些</title>
</head>
<body>
<script>
  /*
  * 对象创建的方式：
  *
  * 1、工厂模式：
  *     工厂模式的主要原理是利用函数封装来创建对象的细节，聪儿通过调用函数来达到复用的目的，但是他有一个很大问题就是创建出来
  *     的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的联系
  * 2、构造函数模式
  *     js中的每个函数都可以作为构造函数，只要一个函数是通过new来调用的，那么就可以把它们称之为构造函数。
  *     执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this
  *     指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象，因为this的值指向了新建的对象，因此可以使用this给
  *     对象赋值，构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是
  *     构造函数的一个缺点就是造成了不必要的函数对象的创建，因为在js中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，练废了不必要的内存空间，
  *     因为函数是所有的实例都可以通用的
  * 3、原型模式
  *     因为每一个函数都有一个prototype属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法，因此可以使用原型对象
  *     来添加属性和方法从而实现代码的福欧阳，这种方式相对于构造函数模式来说，解决了函数对象的复用问题，但是这种模式野村砸一个问题
  *     一个是没有办法通过传入参数来初始化值，另一个就是如果一个引用类型如Array这样的值，那么所有的实例将共享一个对象，一个实例对引用类型之的改变
  *     会影响所有的实例
  *
  * 4、组合使用构造函数和原型模式
  *     这是创建自定义类型的最常见方式，因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式
  *     通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用，这种方法很好的解决了两种模式单独使用时的缺点，
  *     但是有一点·不足的是，因为使用了两种不同的模式，所以对于代码的封装性不够友好
  * 5、动态原型模式
  *     这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性的是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次
  *     的效果，这种方式很好的对上面的混合模式进行了封装
  *
  * 6、寄生构造函数模式
  *     这种模式和工厂模式的实现基本相同，它主要是基于一个已有的类型，在实例化时对实例化的对象进行拓展，这样既不用修改原来的构造函
  *     也达到了拓展对象的目的，他的一个缺点和工程模式一样，无法实现对象的识别
  * */
</script>
</body>
</html>
